<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Assignment-2b (HITS) Documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Documentation of <code>Assignment-2b (HITS)</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_query():
    &#34;&#34;&#34;
    ### Description:
    Takes the query from the input

    ### Args:
    None

    ### Returns:
    returns the entered query
    &#34;&#34;&#34;
    print(&#34;Enter your Query : &#34;, end=&#34;&#34;)
    query = str(input())

    return query


def query_processing(query):
    &#34;&#34;&#34;
    ### Description:
    This method lowers the case of query and returns the query tokens in the form of a list

    ### Args:
    `query`: The query which was entered by the user 

    ### Returns:
    return a list of tokenized words of query
    &#34;&#34;&#34;
    query_tokens = word_tokenize(query.lower())

    return query_tokens


def get_root_set_AND(query_tokens, graph):
    &#34;&#34;&#34;
    ### Description:
    This method is used to find the root set using AND Logic

    ### Args:
    `query_tokens` : list of tokenized words of query.

    `graph` : The graph from which root set is to be found.

    ### Returns:
    returns the root set
    &#34;&#34;&#34;
    root_set = set()

    # Finding the root nodes (Using AND logic)
    for i in graph.nodes:
        temp_page_content = (graph.nodes[i][&#39;page_content&#39;]).lower()
        page_content_tokens = word_tokenize(temp_page_content)
        flag = 1
        for query_token in query_tokens:
            if query_token not in page_content_tokens:
                flag = 0
                break
        if flag == 1:
            root_set.add(i)
        else:
            continue

    return root_set


def get_root_set_OR(query_tokens, graph):
    &#34;&#34;&#34;
    ### Description:
    This method is used to find the root set using OR Logic

    ### Args:
    `query_tokens` : list of tokenized words of query.

    `graph` : The graph from which root set is to be found.

    ### Returns:
    returns the root set
    &#34;&#34;&#34;
    root_set = set()

    # Finding the root nodes (Using OR logic)
    for i in graph.nodes:
        temp_page_content = (graph.nodes[i][&#39;page_content&#39;]).lower()
        page_content_tokens = word_tokenize(temp_page_content)
        for query_token in query_tokens:
            if query_token in page_content_tokens:
                root_set.add(i)

    return root_set


def get_potential_hubs(root_set, graph):
    &#34;&#34;&#34;
    ### Description:
    This method is used to find the all the potential hubs given the root set

    ### Args:
    `root_set`: The root set whose potential hubs are to be found

    `graph` : The graph from which potential hubs are to be found

    ### Returns:
    returns a list having nodes which are potential hubs
    &#34;&#34;&#34;
    potential_hubs = set()
    for node in root_set:
        potential_hubs.update(graph.predecessors(node))

    return potential_hubs


def get_base_set(root_set, potential_hubs):
    &#34;&#34;&#34;
    ### Description:
    This method is used to find base set given potential hubs and root set

    ### Args:
    `root_set`: The root set of a graph for a given query

    `potential_hubs` : The potential hubs of a graph for a given query

    ### Returns:
    returns the base set of the graph for a given query
    &#34;&#34;&#34;
    base_set = root_set.copy()
    base_set.update(potential_hubs)

    return base_set


def make_sub_graph(base_set, graph):
    &#34;&#34;&#34;
    ### Description:
    This method is used to get the sub graph of graph which only contains the nodes of base_set and corresponding edges  

    ### Args:
    `base_set` : The base set from which sub graph is to be made.

    `graph` : The graph from which sub graph is to be made.

    ### Returns:
    returns the required sub graph
    &#34;&#34;&#34;
    sub_graph = graph.subgraph(list(base_set))

    return sub_graph


def print_graph_content(graph):
    &#34;&#34;&#34;
    ### Description:
    prints the attributes and data of each node of th graph

    ### Args:
    `graph`:graph whose data is to be printed

    ### Returns:
    Doesn&#39;t returns anything
    &#34;&#34;&#34;
    for i in graph.nodes:
        print(&#34;Node : &#34;, i)
        print(&#34;pos : &#34;, graph.nodes[i][&#39;pos&#39;])
        print(&#34;page_content : &#34;, graph.nodes[i][&#39;page_content&#39;])
        print(&#34;\n\n&#34;)


def print_graph(graph):
    &#34;&#34;&#34;
    ### Description:
    Draws the graph

    ### Args:
    `graph`:graph which is to be visualized

    ### Returns:
    Doesn&#39;t returns anything
    &#34;&#34;&#34;
    pos = {i: graph.nodes[i][&#39;pos&#39;] for i in graph.nodes}
    nx.draw(graph, pos)


def print_adjacency_list(graph):
    &#34;&#34;&#34;
    ### Description:
    prints the graph in the form of adjacency list

    ### Args:
    `graph`:the graph which needs to be printed in the adjacency list format

    ### Returns:
    Doesn&#39;t returns anything
    &#34;&#34;&#34;
    for source_node in graph.nodes:
        print(source_node, &#34;: &#34;, end=&#34;&#34;)
        for destination_node in graph.neighbors(source_node):
            print(destination_node, end=&#34; &#34;)
        print(&#34;&#34;)


def driver_AND(query, graph):
    &#34;&#34;&#34;
    ### Description:
    This is the driver method, It basically calls all the required method to make the root_set, base_set, and sub graph using AND Logic for tokenized query

    ### Args:
    `query` : The query entered by the user.

    `graph` : The graph from which query is to be searched and sub graph is to be made.

    ### Returns:
    returns root set, base set and sub graph
    &#34;&#34;&#34;
    query_tokens = query_processing(query)

    root_set = get_root_set_AND(query_tokens, graph)
    potential_hubs = get_potential_hubs(root_set, graph)
    base_set = get_base_set(root_set, potential_hubs)

    sub_graph = make_sub_graph(base_set, graph)
    return root_set, base_set, sub_graph


def driver_OR(query, graph):
    &#34;&#34;&#34;
    ### Description:
    This is the driver method, It basically calls all the required method to make the root_set, base_set, and sub graph using OR Logic for tokenized query

    ### Args:
    `query` : The query entered by the user.

    `graph` : The graph from which query is to be searched and sub graph is to be made.

    ### Returns:
    returns root set, base set and sub graph
    &#34;&#34;&#34;
    query_tokens = query_processing(query)

    root_set = get_root_set_OR(query_tokens, graph)
    potential_hubs = get_potential_hubs(root_set, graph)
    base_set = get_base_set(root_set, potential_hubs)

    sub_graph = make_sub_graph(base_set, graph)
    return root_set, base_set, sub_graph


def show_score(node_value):
    &#34;&#34;&#34;
    ### Description:
    Show the hub/authorityvalue of base nodes in descending order by value

    ### Args:
    `node_value`: Dictionary having base_nodes and their corresponding hub/authority score 

    ### Returns:
    Doesn&#39;t return anything
    &#34;&#34;&#34;
    temp_dic = {
        k: v
        for k, v in sorted(node_value.items(), key=lambda item: -item[1])
    }
    for key, value in temp_dic.items():
        print(key, &#39; : &#39;, value)


def print_node_content(nodes, graph):
    &#34;&#34;&#34;
    ### Description:
    prints the content of nodes

    ### Args:
    `nodes`: list which contains the nodes whose content is to be printed

    `graph`: The graph which contains the node whose content is to be printed

    ### Returns:
    Doesn&#39;t returns anything
    &#34;&#34;&#34;
    for i in nodes:
        print(&#34;Node : &#34;, i)
        print(&#34;pos : &#34;, graph.nodes[i][&#39;pos&#39;])
        print(&#34;page_content : &#34;, graph.nodes[i][&#39;page_content&#39;])
        print(&#34;\n\n&#34;)


def show_error_plot(iterations, x):
    &#34;&#34;&#34;
    ### Description:
    prints the content of nodes

    ### Args:
    `nodes`: list which contains the nodes whose content is to be printed

    `graph`: The graph which contains the node whose content is to be printed

    ### Returns:
    Doesn&#39;t returns anything
    &#34;&#34;&#34;
    plt.plot(iterations, x)
    plt.xlabel(&#39;Iterations&#39;)
    plt.ylabel(&#39;Error Value&#39;)
    for i in iterations:
        print(i, &#34; : &#34;, x[i])


def HITS_function(graph, iterations=1000):
    &#34;&#34;&#34;
    ### Description:
    Hyperlink Induced Topic Search (HITS) Algorithm is a Link Analysis Algorithm that rates webpages. This algorithm is used to the web link-structures to discover and rank the webpages relevant for a particular search. HITS uses hubs and authorities to define a recursive relationship between webpages. This function calculates the hubs and authority score for each node in the graph. The Time complexity of HITS Algorithm implemented by us is O(number of iterations * number of edges in the graph).

    ### Args:
    `graph` : The graph on which HITS algorithm is to be implemented.

    `iterations` : The number of iteratons for which the algorithm should be implemented if the scores doesn&#39;t converge.

    ### Returns: 
    `current_hub_score` : The hub score of all the nodes in base set after reaching convergence.

    `current_authority_score` : The authority score of all the nodes in base set after reaching convergence.

    `hub_error_history` : list of error value of hub score for all the iterations.

    `authority_error_history` : list of error value of authority score for all the iterations.

    &#34;&#34;&#34;
    # The error limit at which values are assummed to have converged
    error_limit = 1.0e-10

    current_hub_score = dict.fromkeys(graph, 1.0)
    current_authority_score = dict.fromkeys(graph, 1.0)

    hub_error_history = []
    authority_error_history = []

    for k in range(iterations):
        old_hub = current_hub_score
        old_authority = current_authority_score
        current_hub_score = dict.fromkeys(old_hub.keys(), 0.0)
        current_authority_score = dict.fromkeys(old_authority.keys(), 0.0)

        # Matrix Multiplication for authority score
        for i in current_hub_score:
            for j in graph[i]:
                current_authority_score[j] += old_hub[i] * graph[i][j].get(
                    &#34;weight&#34;, 1)

        # Matrix Multiplication for hub score
        for i in current_hub_score:
            for j in graph[i]:
                current_hub_score[i] += old_authority[j] * graph[i][j].get(
                    &#34;weight&#34;, 1)

        # normalizing the current_hub_score vector
        normalizing_factor = 1.0 / sum(current_hub_score.values())
        for i in current_hub_score:
            current_hub_score[i] *= normalizing_factor

        # normalizing the current_authority_score vector
        normalizing_factor = 1.0 / sum(current_authority_score.values())
        for i in current_authority_score:
            current_authority_score[i] *= normalizing_factor

        # Finding and storing the hub and authority error score
        hub_error = sum(
            abs(current_hub_score[n] - old_hub[n]) for n in current_hub_score)
        authority_error = sum(
            abs(current_authority_score[n] - old_authority[n])
            for n in current_authority_score)

        hub_error_history.append(hub_error)
        authority_error_history.append(authority_error)

        # Condition for convergence
        if hub_error &lt; error_limit and authority_error &lt; error_limit:
            break

    return current_hub_score, current_authority_score, hub_error_history, authority_error_history</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Assignment-2b (HITS).HITS_function"><code class="name flex">
<span>def <span class="ident">HITS_function</span></span>(<span>graph, iterations=1000)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Hyperlink Induced Topic Search (HITS) Algorithm is a Link Analysis Algorithm that rates webpages. This algorithm is used to the web link-structures to discover and rank the webpages relevant for a particular search. HITS uses hubs and authorities to define a recursive relationship between webpages. This function calculates the hubs and authority score for each node in the graph. The Time complexity of HITS Algorithm implemented by us is <b>O(number of iterations * number of edges in the graph)</b>.</p>
<h3 id="args">Args:</h3>
<p><code>graph</code> : The graph on which HITS algorithm is to be implemented.</p>
<p><code>iterations</code> : The number of iteratons for which the algorithm should be implemented if the scores doesn't converge.</p>
<h3 id="returns">Returns:</h3>
<p><code>current_hub_score</code> : The hub score of all the nodes in base set after reaching convergence.</p>
<p><code>current_authority_score</code> : The authority score of all the nodes in base set after reaching convergence.</p>
<p><code>hub_error_history</code> : list of error value of hub score for all the iterations.</p>
<p><code>authority_error_history</code> : list of error value of authority score for all the iterations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HITS_function(graph, iterations=1000):
    &#34;&#34;&#34;
    ### Description:
    Hyperlink Induced Topic Search (HITS) Algorithm is a Link Analysis Algorithm that rates webpages. This algorithm is used to the web link-structures to discover and rank the webpages relevant for a particular search. HITS uses hubs and authorities to define a recursive relationship between webpages. This function calculates the hubs and authority score for each node in the graph. The Time complexity of HITS Algorithm implemented by us is O(number of iterations * number of edges in the graph).

    ### Args:
    `graph` : The graph on which HITS algorithm is to be implemented.

    `iterations` : The number of iteratons for which the algorithm should be implemented if the scores doesn&#39;t converge.

    ### Returns: 
    `current_hub_score` : The hub score of all the nodes in base set after reaching convergence.

    `current_authority_score` : The authority score of all the nodes in base set after reaching convergence.

    `hub_error_history` : list of error value of hub score for all the iterations.

    `authority_error_history` : list of error value of authority score for all the iterations.

    &#34;&#34;&#34;
    # The error limit at which values are assummed to have converged
    error_limit = 1.0e-10

    current_hub_score = dict.fromkeys(graph, 1.0)
    current_authority_score = dict.fromkeys(graph, 1.0)

    hub_error_history = []
    authority_error_history = []

    for k in range(iterations):
        old_hub = current_hub_score
        old_authority = current_authority_score
        current_hub_score = dict.fromkeys(old_hub.keys(), 0.0)
        current_authority_score = dict.fromkeys(old_authority.keys(), 0.0)

        # Matrix Multiplication for authority score
        for i in current_hub_score:
            for j in graph[i]:
                current_authority_score[j] += old_hub[i] * graph[i][j].get(
                    &#34;weight&#34;, 1)

        # Matrix Multiplication for hub score
        for i in current_hub_score:
            for j in graph[i]:
                current_hub_score[i] += old_authority[j] * graph[i][j].get(
                    &#34;weight&#34;, 1)

        # normalizing the current_hub_score vector
        normalizing_factor = 1.0 / sum(current_hub_score.values())
        for i in current_hub_score:
            current_hub_score[i] *= normalizing_factor

        # normalizing the current_authority_score vector
        normalizing_factor = 1.0 / sum(current_authority_score.values())
        for i in current_authority_score:
            current_authority_score[i] *= normalizing_factor

        # Finding and storing the hub and authority error score
        hub_error = sum(
            abs(current_hub_score[n] - old_hub[n]) for n in current_hub_score)
        authority_error = sum(
            abs(current_authority_score[n] - old_authority[n])
            for n in current_authority_score)

        hub_error_history.append(hub_error)
        authority_error_history.append(authority_error)

        # Condition for convergence
        if hub_error &lt; error_limit and authority_error &lt; error_limit:
            break

    return current_hub_score, current_authority_score, hub_error_history, authority_error_history</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).driver_AND"><code class="name flex">
<span>def <span class="ident">driver_AND</span></span>(<span>query, graph)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This is the driver method, It basically calls all the required method to make the root_set, base_set, and sub graph using AND Logic for tokenized query</p>
<h3 id="args">Args:</h3>
<p><code>query</code> : The query entered by the user.</p>
<p><code>graph</code> : The graph from which query is to be searched and sub graph is to be made.</p>
<h3 id="returns">Returns:</h3>
<p>returns root set, base set and sub graph</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def driver_AND(query, graph):
    &#34;&#34;&#34;
    ### Description:
    This is the driver method, It basically calls all the required method to make the root_set, base_set, and sub graph using AND Logic for tokenized query

    ### Args:
    `query` : The query entered by the user.

    `graph` : The graph from which query is to be searched and sub graph is to be made.

    ### Returns:
    returns root set, base set and sub graph
    &#34;&#34;&#34;
    query_tokens = query_processing(query)

    root_set = get_root_set_AND(query_tokens, graph)
    potential_hubs = get_potential_hubs(root_set, graph)
    base_set = get_base_set(root_set, potential_hubs)

    sub_graph = make_sub_graph(base_set, graph)
    return root_set, base_set, sub_graph</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).driver_OR"><code class="name flex">
<span>def <span class="ident">driver_OR</span></span>(<span>query, graph)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This is the driver method, It basically calls all the required method to make the root_set, base_set, and sub graph using OR Logic for tokenized query</p>
<h3 id="args">Args:</h3>
<p><code>query</code> : The query entered by the user.</p>
<p><code>graph</code> : The graph from which query is to be searched and sub graph is to be made.</p>
<h3 id="returns">Returns:</h3>
<p>returns root set, base set and sub graph</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def driver_OR(query, graph):
    &#34;&#34;&#34;
    ### Description:
    This is the driver method, It basically calls all the required method to make the root_set, base_set, and sub graph using OR Logic for tokenized query

    ### Args:
    `query` : The query entered by the user.

    `graph` : The graph from which query is to be searched and sub graph is to be made.

    ### Returns:
    returns root set, base set and sub graph
    &#34;&#34;&#34;
    query_tokens = query_processing(query)

    root_set = get_root_set_OR(query_tokens, graph)
    potential_hubs = get_potential_hubs(root_set, graph)
    base_set = get_base_set(root_set, potential_hubs)

    sub_graph = make_sub_graph(base_set, graph)
    return root_set, base_set, sub_graph</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).get_base_set"><code class="name flex">
<span>def <span class="ident">get_base_set</span></span>(<span>root_set, potential_hubs)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This method is used to find base set given potential hubs and root set</p>
<h3 id="args">Args:</h3>
<p><code>root_set</code>: The root set of a graph for a given query</p>
<p><code>potential_hubs</code> : The potential hubs of a graph for a given query</p>
<h3 id="returns">Returns:</h3>
<p>returns the base set of the graph for a given query</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_base_set(root_set, potential_hubs):
    &#34;&#34;&#34;
    ### Description:
    This method is used to find base set given potential hubs and root set

    ### Args:
    `root_set`: The root set of a graph for a given query

    `potential_hubs` : The potential hubs of a graph for a given query

    ### Returns:
    returns the base set of the graph for a given query
    &#34;&#34;&#34;
    base_set = root_set.copy()
    base_set.update(potential_hubs)

    return base_set</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).get_potential_hubs"><code class="name flex">
<span>def <span class="ident">get_potential_hubs</span></span>(<span>root_set, graph)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This method is used to find the all the potential hubs given the root set</p>
<h3 id="args">Args:</h3>
<p><code>root_set</code>: The root set whose potential hubs are to be found</p>
<p><code>graph</code> : The graph from which potential hubs are to be found</p>
<h3 id="returns">Returns:</h3>
<p>returns a list having nodes which are potential hubs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_potential_hubs(root_set, graph):
    &#34;&#34;&#34;
    ### Description:
    This method is used to find the all the potential hubs given the root set

    ### Args:
    `root_set`: The root set whose potential hubs are to be found

    `graph` : The graph from which potential hubs are to be found

    ### Returns:
    returns a list having nodes which are potential hubs
    &#34;&#34;&#34;
    potential_hubs = set()
    for node in root_set:
        potential_hubs.update(graph.predecessors(node))

    return potential_hubs</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).get_query"><code class="name flex">
<span>def <span class="ident">get_query</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Takes the query from the input</p>
<h3 id="args">Args:</h3>
<p>None</p>
<h3 id="returns">Returns:</h3>
<p>returns the entered query</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_query():
    &#34;&#34;&#34;
    ### Description:
    Takes the query from the input

    ### Args:
    None

    ### Returns:
    returns the entered query
    &#34;&#34;&#34;
    print(&#34;Enter your Query : &#34;, end=&#34;&#34;)
    query = str(input())

    return query</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).get_root_set_AND"><code class="name flex">
<span>def <span class="ident">get_root_set_AND</span></span>(<span>query_tokens, graph)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This method is used to find the root set using AND Logic</p>
<h3 id="args">Args:</h3>
<p><code>query_tokens</code> : list of tokenized words of query.</p>
<p><code>graph</code> : The graph from which root set is to be found.</p>
<h3 id="returns">Returns:</h3>
<p>returns the root set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_root_set_AND(query_tokens, graph):
    &#34;&#34;&#34;
    ### Description:
    This method is used to find the root set using AND Logic

    ### Args:
    `query_tokens` : list of tokenized words of query.

    `graph` : The graph from which root set is to be found.

    ### Returns:
    returns the root set
    &#34;&#34;&#34;
    root_set = set()

    # Finding the root nodes (Using AND logic)
    for i in graph.nodes:
        temp_page_content = (graph.nodes[i][&#39;page_content&#39;]).lower()
        page_content_tokens = word_tokenize(temp_page_content)
        flag = 1
        for query_token in query_tokens:
            if query_token not in page_content_tokens:
                flag = 0
                break
        if flag == 1:
            root_set.add(i)
        else:
            continue

    return root_set</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).get_root_set_OR"><code class="name flex">
<span>def <span class="ident">get_root_set_OR</span></span>(<span>query_tokens, graph)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This method is used to find the root set using OR Logic</p>
<h3 id="args">Args:</h3>
<p><code>query_tokens</code> : list of tokenized words of query.</p>
<p><code>graph</code> : The graph from which root set is to be found.</p>
<h3 id="returns">Returns:</h3>
<p>returns the root set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_root_set_OR(query_tokens, graph):
    &#34;&#34;&#34;
    ### Description:
    This method is used to find the root set using OR Logic

    ### Args:
    `query_tokens` : list of tokenized words of query.

    `graph` : The graph from which root set is to be found.

    ### Returns:
    returns the root set
    &#34;&#34;&#34;
    root_set = set()

    # Finding the root nodes (Using OR logic)
    for i in graph.nodes:
        temp_page_content = (graph.nodes[i][&#39;page_content&#39;]).lower()
        page_content_tokens = word_tokenize(temp_page_content)
        for query_token in query_tokens:
            if query_token in page_content_tokens:
                root_set.add(i)

    return root_set</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).make_sub_graph"><code class="name flex">
<span>def <span class="ident">make_sub_graph</span></span>(<span>base_set, graph)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This method is used to get the sub graph of graph which only contains the nodes of base_set and corresponding edges
</p>
<h3 id="args">Args:</h3>
<p><code>base_set</code> : The base set from which sub graph is to be made.</p>
<p><code>graph</code> : The graph from which sub graph is to be made.</p>
<h3 id="returns">Returns:</h3>
<p>returns the required sub graph</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_sub_graph(base_set, graph):
    &#34;&#34;&#34;
    ### Description:
    This method is used to get the sub graph of graph which only contains the nodes of base_set and corresponding edges  

    ### Args:
    `base_set` : The base set from which sub graph is to be made.

    `graph` : The graph from which sub graph is to be made.

    ### Returns:
    returns the required sub graph
    &#34;&#34;&#34;
    sub_graph = graph.subgraph(list(base_set))

    return sub_graph</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).print_adjacency_list"><code class="name flex">
<span>def <span class="ident">print_adjacency_list</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>prints the graph in the form of adjacency list</p>
<h3 id="args">Args:</h3>
<p><code>graph</code>:the graph which needs to be printed in the adjacency list format</p>
<h3 id="returns">Returns:</h3>
<p>Doesn't returns anything</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_adjacency_list(graph):
    &#34;&#34;&#34;
    ### Description:
    prints the graph in the form of adjacency list

    ### Args:
    `graph`:the graph which needs to be printed in the adjacency list format

    ### Returns:
    Doesn&#39;t returns anything
    &#34;&#34;&#34;
    for source_node in graph.nodes:
        print(source_node, &#34;: &#34;, end=&#34;&#34;)
        for destination_node in graph.neighbors(source_node):
            print(destination_node, end=&#34; &#34;)
        print(&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).print_graph"><code class="name flex">
<span>def <span class="ident">print_graph</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Draws the graph</p>
<h3 id="args">Args:</h3>
<p><code>graph</code>:graph which is to be visualized</p>
<h3 id="returns">Returns:</h3>
<p>Doesn't returns anything</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_graph(graph):
    &#34;&#34;&#34;
    ### Description:
    Draws the graph

    ### Args:
    `graph`:graph which is to be visualized

    ### Returns:
    Doesn&#39;t returns anything
    &#34;&#34;&#34;
    pos = {i: graph.nodes[i][&#39;pos&#39;] for i in graph.nodes}
    nx.draw(graph, pos)</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).print_graph_content"><code class="name flex">
<span>def <span class="ident">print_graph_content</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>prints the attributes and data of each node of th graph</p>
<h3 id="args">Args:</h3>
<p><code>graph</code>:graph whose data is to be printed</p>
<h3 id="returns">Returns:</h3>
<p>Doesn't returns anything</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_graph_content(graph):
    &#34;&#34;&#34;
    ### Description:
    prints the attributes and data of each node of th graph

    ### Args:
    `graph`:graph whose data is to be printed

    ### Returns:
    Doesn&#39;t returns anything
    &#34;&#34;&#34;
    for i in graph.nodes:
        print(&#34;Node : &#34;, i)
        print(&#34;pos : &#34;, graph.nodes[i][&#39;pos&#39;])
        print(&#34;page_content : &#34;, graph.nodes[i][&#39;page_content&#39;])
        print(&#34;\n\n&#34;)</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).print_node_content"><code class="name flex">
<span>def <span class="ident">print_node_content</span></span>(<span>nodes, graph)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>prints the content of nodes</p>
<h3 id="args">Args:</h3>
<p><code>nodes</code>: list which contains the nodes whose content is to be printed</p>
<p><code>graph</code>: The graph which contains the node whose content is to be printed</p>
<h3 id="returns">Returns:</h3>
<p>Doesn't returns anything</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_node_content(nodes, graph):
    &#34;&#34;&#34;
    ### Description:
    prints the content of nodes

    ### Args:
    `nodes`: list which contains the nodes whose content is to be printed

    `graph`: The graph which contains the node whose content is to be printed

    ### Returns:
    Doesn&#39;t returns anything
    &#34;&#34;&#34;
    for i in nodes:
        print(&#34;Node : &#34;, i)
        print(&#34;pos : &#34;, graph.nodes[i][&#39;pos&#39;])
        print(&#34;page_content : &#34;, graph.nodes[i][&#39;page_content&#39;])
        print(&#34;\n\n&#34;)</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).query_processing"><code class="name flex">
<span>def <span class="ident">query_processing</span></span>(<span>query)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This method lowers the case of query and returns the query tokens in the form of a list</p>
<h3 id="args">Args:</h3>
<p><code>query</code>: The query which was entered by the user </p>
<h3 id="returns">Returns:</h3>
<p>return a list of tokenized words of query</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query_processing(query):
    &#34;&#34;&#34;
    ### Description:
    This method lowers the case of query and returns the query tokens in the form of a list

    ### Args:
    `query`: The query which was entered by the user 

    ### Returns:
    return a list of tokenized words of query
    &#34;&#34;&#34;
    query_tokens = word_tokenize(query.lower())

    return query_tokens</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).show_error_plot"><code class="name flex">
<span>def <span class="ident">show_error_plot</span></span>(<span>iterations, x)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>prints the content of nodes</p>
<h3 id="args">Args:</h3>
<p><code>nodes</code>: list which contains the nodes whose content is to be printed</p>
<p><code>graph</code>: The graph which contains the node whose content is to be printed</p>
<h3 id="returns">Returns:</h3>
<p>Doesn't returns anything</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_error_plot(iterations, x):
    &#34;&#34;&#34;
    ### Description:
    prints the content of nodes

    ### Args:
    `nodes`: list which contains the nodes whose content is to be printed

    `graph`: The graph which contains the node whose content is to be printed

    ### Returns:
    Doesn&#39;t returns anything
    &#34;&#34;&#34;
    plt.plot(iterations, x)
    plt.xlabel(&#39;Iterations&#39;)
    plt.ylabel(&#39;Error Value&#39;)
    for i in iterations:
        print(i, &#34; : &#34;, x[i])</code></pre>
</details>
</dd>
<dt id="Assignment-2b (HITS).show_score"><code class="name flex">
<span>def <span class="ident">show_score</span></span>(<span>node_value)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Show the hub/authorityvalue of base nodes in descending order by value</p>
<h3 id="args">Args:</h3>
<p><code>node_value</code>: Dictionary having base_nodes and their corresponding hub/authority score </p>
<h3 id="returns">Returns:</h3>
<p>Doesn't return anything</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_score(node_value):
    &#34;&#34;&#34;
    ### Description:
    Show the hub/authorityvalue of base nodes in descending order by value

    ### Args:
    `node_value`: Dictionary having base_nodes and their corresponding hub/authority score 

    ### Returns:
    Doesn&#39;t return anything
    &#34;&#34;&#34;
    temp_dic = {
        k: v
        for k, v in sorted(node_value.items(), key=lambda item: -item[1])
    }
    for key, value in temp_dic.items():
        print(key, &#39; : &#39;, value)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Assignment-2b (HITS).HITS_function" href="#Assignment-2b (HITS).HITS_function">HITS_function</a></code></li>
<li><code><a title="Assignment-2b (HITS).driver_AND" href="#Assignment-2b (HITS).driver_AND">driver_AND</a></code></li>
<li><code><a title="Assignment-2b (HITS).driver_OR" href="#Assignment-2b (HITS).driver_OR">driver_OR</a></code></li>
<li><code><a title="Assignment-2b (HITS).get_base_set" href="#Assignment-2b (HITS).get_base_set">get_base_set</a></code></li>
<li><code><a title="Assignment-2b (HITS).get_potential_hubs" href="#Assignment-2b (HITS).get_potential_hubs">get_potential_hubs</a></code></li>
<li><code><a title="Assignment-2b (HITS).get_query" href="#Assignment-2b (HITS).get_query">get_query</a></code></li>
<li><code><a title="Assignment-2b (HITS).get_root_set_AND" href="#Assignment-2b (HITS).get_root_set_AND">get_root_set_AND</a></code></li>
<li><code><a title="Assignment-2b (HITS).get_root_set_OR" href="#Assignment-2b (HITS).get_root_set_OR">get_root_set_OR</a></code></li>
<li><code><a title="Assignment-2b (HITS).make_sub_graph" href="#Assignment-2b (HITS).make_sub_graph">make_sub_graph</a></code></li>
<li><code><a title="Assignment-2b (HITS).print_adjacency_list" href="#Assignment-2b (HITS).print_adjacency_list">print_adjacency_list</a></code></li>
<li><code><a title="Assignment-2b (HITS).print_graph" href="#Assignment-2b (HITS).print_graph">print_graph</a></code></li>
<li><code><a title="Assignment-2b (HITS).print_graph_content" href="#Assignment-2b (HITS).print_graph_content">print_graph_content</a></code></li>
<li><code><a title="Assignment-2b (HITS).print_node_content" href="#Assignment-2b (HITS).print_node_content">print_node_content</a></code></li>
<li><code><a title="Assignment-2b (HITS).query_processing" href="#Assignment-2b (HITS).query_processing">query_processing</a></code></li>
<li><code><a title="Assignment-2b (HITS).show_error_plot" href="#Assignment-2b (HITS).show_error_plot">show_error_plot</a></code></li>
<li><code><a title="Assignment-2b (HITS).show_score" href="#Assignment-2b (HITS).show_score">show_score</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>